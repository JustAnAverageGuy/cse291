<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UDP Overview</title>
    <!-- Add Bootstrap CSS -->
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Custom styles */
        #animation-container {
            height: 600px;
            border: 1px solid #ccc;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            background-color: #f8f9fa;
        }

        .header {
            fill: black;
            font-weight: bold;
            font-size: 14px;
            text-anchor: middle;
        }

        .detail-box {
            position: absolute;
            background-color: #fff;
            border: 1px solid #000;
            padding: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            z-index: 999;
            display: none;
            max-width: 200px;
            text-align: left;
            font-size: 12px;
        }

        .pop-up {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    border-radius: 5px;
    color: #fff;
    font-weight: bold;
    z-index: 1000;
}



.success {
    background-color: #28a745; /* Green */
}

.failure {
    background-color: #dc3545; /* Red */
}


        input[type="text"],
        button {
            margin: 5px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <header class="bg-dark text-white py-4">
        <div class="container">
            <h1 class="mb-0">Understanding UDP (User Datagram Protocol)</h1>
        </div>
    </header>
    <section id="instruction" class="py-4">
        <div class="container">
            <h2>Instruction</h2>
            <p>
                User Datagram Protocol (UDP) is one of the core communication protocols of the
                Internet protocol suite used to send messages (transported as datagrams in packets) to other hosts on an
                Internet Protocol (IP) network. Within an IP network, UDP does not require prior communication to set up
                communication channels or data paths.
            </p>
            <p>
                UDP uses a simple connectionless communication model with a minimum of protocol mechanisms. UDP
                provides checksums for data integrity, and port numbers for addressing different functions at
                the source and destination of the datagram. It has no handshaking dialogues and thus exposes the
                user's program to any unreliability of the underlying network; there is no guarantee of
                delivery, ordering, or duplicate protection. If error-correction facilities are needed at the
                network interface level, an application may instead use Transmission Control Protocol (TCP) or
                Stream Control Transmission Protocol (SCTP) which are designed for this purpose.
            </p>
            <p>
                UDP is suitable for purposes where error checking and correction are either not necessary or are
                performed in the application; UDP avoids the overhead of such processing in the protocol stack.
                Time-sensitive applications often use UDP because dropping packets is preferable to waiting for
                packets delayed due to retransmission, which may not be an option in a real-time system.
    
                The protocol was designed by David P. Reed in 1980 and formally defined in <a
                    href="https://datatracker.ietf.org/doc/html/rfc768">RFC 768</a>.
            </p>
            <h3> Datagram format specification </h3>
            <p>
                A UDP datagram consists of a datagram header followed by a data section (the payload data for the
                application).<br> The UDP datagram header consists of 4 fields, each of which is 2 bytes (16 bits)
            </p>
    
    
            <pre class="header-format" >
                          0      7 8     15 16    23 24    31
                         +--------+--------+--------+--------+
                         |     Source      |   Destination   |
                         |      Port       |      Port       |
                         +--------+--------+--------+--------+
                         |                 |                 |
                         |     Length      |    Checksum     |
                         +--------+--------+--------+--------+
                         |
                         |          data octets ...
                         +---------------- ...
    
                              User Datagram Header Format</pre>
            <h4>Fields</h4>
            <ul>
                <li>Source Port is an optional field, when meaningful, it indicates the port
                    of the sending process, and may be assumed to be the port to which a
                    reply should be addressed in the absence of any other information. If
                    not used, a value of zero is inserted.</li>
                <li>
                    Destination Port has a meaning within the context of a particular
                    internet destination address.
                </li>
    
                <li>
                    Length is the length in octets of this user datagram including this
                    header and the data. (This means the minimum value of the length is
                    eight.)
                </li>
    
                <li>
                    Checksum is the 16-bit one's complement of the one's complement sum of a
                    pseudo header of information from the IP header, the UDP header, and the
                    data, padded with zero octets at the end (if necessary) to make a
                    multiple of two octets.
    
                    The pseudo header conceptually prefixed to the UDP header contains the
                    source address, the destination address, the protocol, and the UDP
                    length. This information gives protection against misrouted datagrams.
                    This checksum procedure is the same as is used in TCP.
                    <pre class="header-format">                  0      7 8     15 16    23 24    31
                     +--------+--------+--------+--------+
                     |          source address           |
                     +--------+--------+--------+--------+
                     |        destination address        |
                     +--------+--------+--------+--------+
                     |  zero  |protocol|   UDP length    |
                     +--------+--------+--------+--------+
                                Psudo Header</pre>
    
                </li>
            </ul>
        </div>
    </section>
    
    <!-- Add other sections with Bootstrap styles -->
    <section id="animation" class="py-4">
        <div class="container">
            <h2 class="mb-4">Interactive Animation: UDP Communication Process</h2>
            <form id="input-form">
                <div class="form-group">
                    <label for="source-port">Source Port:</label>
                    <input type="text" class="form-control" id="source-port" value="1234">
                </div>
                <div class="form-group">
                    <label for="destination-port">Destination Port:</label>
                    <input type="text" class="form-control" id="destination-port" value="5678">
                </div>
                <div class="form-group">
                    <label for="message">Message:</label>
                    <input type="text" class="form-control" id="message" placeholder="Enter message to send">
                </div>
                <button type="button" class="btn btn-primary" onclick="startAnimation()">Start Animation</button>
            </form>
            <div id="animation-container" class="mt-4"></div>
            <div id="detail-box" class="detail-box"></div>
        </div>
    </section>
    <footer class="bg-dark text-white py-4">
        <div class="container">
            <p>For more detailed information, refer to RFC 768 (UDP specification).</p>
        </div>
        <section id="quiz" class="py-4">
            <div class="container">
                <h2 class="mb-4">Quiz Section</h2>
                <button type="button" class="btn btn-primary" onclick="startQuiz()">Start Quiz</button>
                <div id="quiz-container" style="display: none;">
                <div class="quiz-question">
                    
                    <h3>Question 1:</h3>
                    <p>What is the length of UDP including the header and the data?</p>
                    <div class="quiz-options">
                        <label><input type="radio" name="quiz-q1" value="a"> 8 bits</label>
                        <label><input type="radio" name="quiz-q1" value="b"> 16 bits</label>
                        <label><input type="radio" name="quiz-q1" value="c"> 32 bits</label>
                        <label><input type="radio" name="quiz-q1" value="d"> 64 bits</label>
                    </div>
                    <button type="button" class="btn btn-primary" onclick="checkAnswer('b')">Submit Answer</button>

                    <h3>Question 2:</h3>
                    <p>Which of the following is false with respect to UDP?</p>
                    <div class="quiz-options">
                        <label><input type="radio" name="quiz-q1" value="a"> Connection Oriented</label>
                        <label><input type="radio" name="quiz-q1" value="b"> Unreliable</label>
                        <label><input type="radio" name="quiz-q1" value="c"> Transport Layer Protocol</label>
                        <label><input type="radio" name="quiz-q1" value="d"> Low overhead</label>
                    </div>
                    <button type="button" class="btn btn-primary" onclick="checkAnswer('a')">Submit Answer</button>

                    <h3>Question 3:</h3>
                    <p>The ______ field is used to detect errors over the entire user datagram</p>
                    <div class="quiz-options">
                        <label><input type="radio" name="quiz-q1" value="a"> UDP header</label>
                        <label><input type="radio" name="quiz-q1" value="b"> checksum</label>
                        <label><input type="radio" name="quiz-q1" value="c"> source Port</label>
                        <label><input type="radio" name="quiz-q1" value="d"> Destination port</label>
                    </div>
                    <button type="button" class="btn btn-primary" onclick="checkAnswer('b')">Submit Answer</button>

                    
                </div>
            </div>
            </div>
        </section>
    </footer>

    <!-- Include Bootstrap JS and D3.js library -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // JavaScript code for creating the animated flowchart
       // JavaScript code for creating the animated flowchart
function startAnimation() {
    // Remove the existing SVG element if it exists
    d3.select("#animation-container").select("svg").remove();

    const sourcePort = document.getElementById("source-port").value;
    const destinationPort = document.getElementById("destination-port").value;
    const message = document.getElementById("message").value; // Get the message from the input field

    // Create an SVG container for the animation
    const svg = d3.select("#animation-container")
        .append("svg")
        .attr("width", "100%")
        .attr("height", "100%");

    // Define the coordinates for each box and arrow
    const boxCoords = [
        { x: 50, y: 200, title: "Sender", subTitle: "Sender Side", content: "Data being sent" },
        { x: 300, y: 200, title: "UDP Header", subTitle: "UDP Header", content: `Source Port: Source Port is a 2 Byte long field used to identify the port number of the source.<br>Destination Port: It is a 2 Byte long field, used to identify the port of the destined packet.<br>Length: Length is the length of UDP including the header and the data. It is a 16-bits field.<br>Checksum: Checksum is 2 Bytes long field. It is the 16-bit one’s complement of the one’s complement sum of the UDP header, the pseudo-header of information from the IP header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.` },
        { x: 550, y: 200, title: "IP Header", subTitle: "IP Header", content: `Version: Version of the IP protocol (4 bits), which is 4 for IPv4<br>HLEN: IP header length (4 bits), which is the number of 32 bit words in the header. The minimum value for this field is 5 and the maximum is 15.<br>Type of service: Low Delay, High Throughput, Reliability (8 bits)<br>Total Length: Length of header + Data (16 bits), which has a minimum value 20 bytes and the maximum is 65,535 bytes.<br>Identification: Unique Packet Id for identifying the group of fragments of a single IP datagram (16 bits)<br>Flags: 3 flags of 1 bit each: reserved bit (must be zero), do not fragment flag, more fragments flag (same order)<br>Fragment Offset: Represents the number of Data Bytes ahead of the particular fragment in the particular Datagram. Specified in terms of number of 8 bytes, which has the maximum value of 65,528 bytes.<br>Time to live: Datagram’s lifetime (8 bits), It prevents the datagram to loop through the network by restricting the number of Hops taken by a Packet before delivering to the Destination.<br>Protocol: Name of the protocol (8 bits)<br>Header Checksum: 16 bits header checksum for checking errors in the datagram header<br>Source IP address: 32 bits IP address of the sender<br>Destination IP address: 32 bits IP address of the receiver<br>Option: Optional information such as source route, record route.` },
        { x: 800, y: 200, title: "Receiver", subTitle: "Receiver Side", content: "" }
    ];

    // Draw each box and arrow sequentially with delays
    boxCoords.forEach((coords, index) => {
        setTimeout(() => {
            const group = svg.append("g").attr("class", "animated-group");

            // Draw the box
            const rect = group.append("rect")
                .attr("x", coords.x)
                .attr("y", coords.y)
                .attr("width", 200)
                .attr("height", 100)
                .style("fill", "#f0f0f0")
                .style("stroke", "#000")
                .style("stroke-width", 2)
                .on("mouseover", () => showDetail(coords.title, coords.subTitle, coords.content));

            // Add text inside the box
            group.append("text")
                .attr("x", coords.x + 100)
                .attr("y", coords.y + 40)
                .text(coords.title)
                .attr("class", "header");

            // Draw arrow except for the last box
            if (index < boxCoords.length - 1) {
                const nextCoords = boxCoords[index + 1];
                svg.append("line")
                    .attr("x1", coords.x + 200)
                    .attr("y1", coords.y + 50)
                    .attr("x2", nextCoords.x)
                    .attr("y2", nextCoords.y + 50)
                    .attr("stroke", "black")
                    .attr("stroke-width", 2);
            }

            // Animate data packet movement
            if (coords.title === "Sender" && index === 0) {
                const dataPacket = group.append("rect")
                    .attr("x", coords.x + 100)
                    .attr("y", coords.y + 20)
                    .attr("width", 20)
                    .attr("height", 20)
                    .attr("class", "data-packet");
            }
        }, index * 2000); // Delay each box by 2 seconds (adjust as needed)
    });
}


        function startQuiz() {
    // Show or hide the quiz container based on its current display state
    const quizContainer = document.getElementById('quiz-container');
    quizContainer.style.display = quizContainer.style.display === 'none' ? 'block' : 'none';
}

        // Function to show detail box near the hovered element and display data
        function showDetail(title, subTitle, content) {
            const detailBox = document.getElementById("detail-box");
            detailBox.innerHTML = `<h3>${title}</h3><h4>${subTitle}</h4><p>${content}</p>`;

            // Display the detail box near the hovered element
            const boundingBox = event.target.getBoundingClientRect();
            const posX = boundingBox.left + window.pageXOffset + (boundingBox.width - detailBox.offsetWidth) / 2;
            const posY = boundingBox.top + window.pageYOffset - detailBox.offsetHeight - 10;
            detailBox.style.left = posX + "px";
            detailBox.style.top = posY + "px";

            detailBox.style.display = "block";
        }

        function showPopUp(message, isSuccess) {
    const popUp = document.createElement("div");
    popUp.className = isSuccess ? "pop-up success" : "pop-up failure";
    popUp.textContent = message;

    document.body.appendChild(popUp);

    // Automatically remove the pop-up after a few seconds
    setTimeout(() => {
        popUp.remove();
    }, 3000); // Adjust the timeout as needed
}

function checkAnswer(correctOption) {
    const selectedOption = document.querySelector('input[name="quiz-q1"]:checked');

    if (selectedOption && selectedOption.value === correctOption) {
        showPopUp("Correct Answer! Well done!", true);
    } else {
        showPopUp("Incorrect Answer. Try again!", false);
    }
}


        // Attach event listeners to elements for hovering effect and data display
        document.querySelectorAll(".header").forEach(element => {
            element.addEventListener("mouseover", () => {
                let title, subTitle, content;
                if (element.parentElement.classList.contains("sender-group")) {
                    title = "Sender";
                    subTitle = "Sender Side";
                    content = "Data being sent";
                } else if (element.parentElement.classList.contains("udp-header-group")) {
                    title = "UDP Header";
                    subTitle = "UDP Header";
                    const sourcePort = document.getElementById("source-port").value;
                    const destinationPort = document.getElementById("destination-port").value;
                    content = `Source Port: ${sourcePort}<br>Destination Port: ${destinationPort}<br>Checksum: ${Math.floor(Math.random() * 65535)}`;
                } else if (element.parentElement.classList.contains("ip-header-group")) {
                    title = "IP Header";
                    subTitle = "IP Header";
                    content = `Version: 4<br>HLEN: 5<br>Type of service: Low Delay, High Throughput, Reliability<br>Total Length: 20 bytes<br>Identification: Unique Packet Id<br>Flags: Reserved bit (must be zero), do not fragment flag, more fragments flag<br>Fragment Offset: Number of Data Bytes ahead of the particular fragment<br>Time to live: Datagram’s lifetime<br>Protocol: Name of the protocol<br>Header Checksum: 16 bits header checksum<br>Source IP address: Sender's IP address<br>Destination IP address: Receiver's IP address<br>Option: Optional information such as source route, record route`;
                }
                showDetail(title, subTitle, content);
            });
            element.addEventListener("mouseleave", () => {
                const detailBox = document.getElementById("detail-box");
                detailBox.style.display = "none";
            });
        });
    </script>
</body>
</html>
